library(sqldf)
library(Metrics)
library(rpart)
library(caret)
library(dplyr)

source("src/timefunctions.R")
source("src/errorfunctions.R")

#Event log, created by exporting csv from Disco and then zipping the result
data <- data.frame(read.csv(unz("data/1.zip","1.csv"), header = TRUE, sep = ";", quote = "\"", dec = "."))
data$Complete.Timestamp <- as.POSIXct(strptime(data$Complete.Timestamp, "%Y/%m/%d %H:%M:%S", tz = "GMT"))

#Aggregate the cases from the event log
cases <- sqldf('SELECT 
                    `Case.ID` AS caseid,
                    GROUP_CONCAT(Activity) AS activities,
                    GROUP_CONCAT(Resource) AS resources,
                    Variant as variant,
                    GROUP_CONCAT(amount) AS amount,
                    GROUP_CONCAT(article) AS article,
                    GROUP_CONCAT(points) AS points,
                    GROUP_CONCAT(vehicleClass,"") AS vehicleclass,
                    GROUP_CONCAT(totalPaymentAmount) AS total,
                    MIN(`Complete.Timestamp`) AS starttime, 
                    MAX(`Complete.Timestamp`) AS endtime, 
                    MAX(`Complete.Timestamp`) - MIN(`Complete.Timestamp`) AS proctime 
                FROM data GROUP BY `Case.ID`')
cases$amount = as.numeric(cases$amount)
cases$points = as.numeric(cases$points)
#The relation that must be learned to predict the class of a case (Easy, Hard, ...)
relation = class ~ amount + article + points + vehicleclass

################################################################################
#
# The method below will try to predict the proctime
# Preconditions:
# - A data.frame named 'cases' must exist that has a column 'proctime'
# - The 'relation' above must be defined, which relates 'class' to other properties of a case
#
################################################################################


################################################################################
#
# Helper functions
#
################################################################################

# attaching the actual class of a case
# return set with additional column 'class'
f.addclass <- function(cases.subset){
  mean.proctime <- mean(cases.subset$proctime)
  median.error <- median(abs(cases.subset$proctime - mean.proctime))
  f.class <- function(proctimevalue){
    if (abs(proctimevalue-mean.proctime) < median.error){
      return("Easy")
    }else{
      return("Hard")
    }
  }
  cases.subset$class = mapply(f.class,cases.subset$proctime)
  return(cases.subset)
}

# learning the class of a case based on other variables
# return model
# precondition: contains a column 'class', which can be generated by 'f.addclass'
f.learnclass <- function(cases.subset){
  fit <- rpart(relation, method="class", data=cases.subset)
  pfit<- prune(fit, cp=fit$cptable[which.min(fit$cptable[,"xerror"]),"CP"])
  return(pfit)
}

# learning the proctime of a case per class based on other variables
# return vector of models
# precondition: contains a column 'class', which can be generated by 'f.addclass'
f.learnproctime <- function(cases.subset){
  mean.proctime.easy = mean(cases.subset[cases.subset$class=="Easy",]$proctime)
  mean.proctime.hard = mean(cases.subset[cases.subset$class=="Hard",]$proctime)
  predictionfunctions = c(
    function(row){return(mean.proctime.easy)},
    function(row){return(mean.proctime.hard)}
  )
  names(predictionfunctions) = c("Easy","Hard")
  return(predictionfunctions)
}

# predicting the class of a case based on other variables
# return set with additional column 'predictedclass'
f.predictclass <- function(cases.subset, model){
  cases.subset$predictedclass = predict(model,cases.subset,type="class")
  return(cases.subset)
}

# predicting the throughput time of a class 
# return set with additional column 'predictedproctime'
# precondition: contains a column 'predictedclass', which can be generated by 'f.predictclass'
f.predictproctime <- function(cases.subset, modelvector){
  classes = unique(cases.subset$predictedclass)
  cases.subset$predictedproctime = 0
  for (class in classes){
    cases.subset[cases.subset$predictedclass == class,]$predictedproctime = modelvector[[class]](cases.subset[cases.subset$predictedclass == class,])
  }
  return(cases.subset)
}

################################################################################
#
# The actual procedure with cross validation
#
################################################################################

k = 10

cases = f.addclass(cases)
classes = unique(cases$class)

folds <- createFolds(cases$proctime, k)

mae.avg = 0
rmse.avg = 0
smape.avg = 0
smape.avg.byclass = vector(mode = "numeric", length = length(classes))
names(smape.avg.byclass) = classes

for (i in 1:k){
  cases.train <- cases[-folds[[i]],]
  cases.test <- cases[folds[[i]],]

  model.class = f.learnclass(cases.train)
  modelvector.proctime = f.learnproctime(cases.train)
  
  cases.test = f.predictclass(cases.test, model.class)
  cases.test = f.predictproctime(cases.test, modelvector.proctime)
  
  mae.avg = mae.avg + mae(cases.test$proctime, cases.test$predictedproctime)
  rmse.avg = rmse.avg + rmse(cases.test$proctime, cases.test$predictedproctime)
  smape.avg = smape.avg + smape(cases.test$proctime, cases.test$predictedproctime)
  for (class in classes){
    smape.avg.byclass[[class]] = smape.avg.byclass[[class]] + smape(cases.test[cases.test$class==class,]$proctime, cases.test[cases.test$class==class,]$predictedproctime)
  }
}

mae.avg = mae.avg/k
rmse.avg = rmse.avg/k
smape.avg = smape.avg/k
for (class in classes){
  smape.avg.byclass[[class]] = smape.avg.byclass[[class]]/k
}

print(mae.avg)
print(rmse.avg)
print(smape.avg)
print(smape.avg.byclass)